I"üP<p>æœ€è¿‘é¡¹ç›®åšåˆ°ç”¨æˆ·è‡ªå®šä¹‰å¤´åƒåŠŸèƒ½æ¨¡å—ï¼Œç„¶åä»¿ç…§å¾®ä¿¡åšäº†ä¸€ä¸ªï¼ŒåŠŸèƒ½åŒ…æ‹¬ç…§ç‰‡æ‹æ‘„å’Œå›¾ç‰‡è£å‰ªã€‚</p>

<p><strong>ä½¿ç”¨ç›¸æœºæ‹ç…§</strong></p>
<ul>
  <li>
    <p>å¯¼å…¥éœ€è¦çš„æ¡†æ¶</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  #import &lt;AVFoundation/AVFoundation.h&gt; 
</code></pre></div>    </div>
  </li>
  <li>
    <p>åˆ›å»ºç›¸æœº</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      /** æ•è·è®¾å¤‡ï¼Œé€šå¸¸æ˜¯å‰ç½®æ‘„åƒå¤´ï¼Œåç½®æ‘„åƒå¤´ï¼Œéº¦å…‹é£ï¼ˆéŸ³é¢‘è¾“å…¥ï¼‰ */  
      @property (strong, nonatomic) AVCaptureDevice *device;  
	      
      /** ä»£è¡¨è¾“å…¥è®¾å¤‡ï¼Œä½¿ç”¨AVCaptureDeviceåˆå§‹åŒ– */  
      @property (strong, nonatomic) AVCaptureDeviceInput *input;  
	      
      /** è¾“å‡ºå›¾ç‰‡ */  
      @property (strong, nonatomic) AVCaptureStillImageOutput *imageOutput;  
	      
      /** ç”±ä»–å°†è¾“å…¥è¾“å‡ºç»“åˆåœ¨ä¸€èµ·ï¼Œå¹¶å¼€å§‹å¯åŠ¨æ•è·è®¾å¤‡ï¼ˆæ‘„åƒå¤´ï¼‰ */  
      @property (strong, nonatomic) AVCaptureSession *session;  
	      
      /** å›¾åƒé¢„è§ˆå±‚ï¼Œå®æ—¶æ˜¾ç¤ºæ•è·çš„å›¾åƒ */  
      @property (strong, nonatomic) AVCaptureVideoPreviewLayer *previewLayer;  
	
      /* åˆ›å»ºç›¸æœº */
      - (void)createCameraDistrict{  
	          
          //è·å–åç½®æ‘„åƒå¤´  
	        
          self.device = [self camerWithPosition:AVCaptureDevicePositionBack];  
          self.input = [[AVCaptureDeviceInput alloc] initWithDevice:self.device error:nil];  
	          
          self.imageOutput = [[AVCaptureStillImageOutput alloc] init];  
          self.session = [[AVCaptureSession alloc] init];  
	          
          //è®¾ç½®è·å–å›¾ç‰‡çš„è´¨é‡  
	        
          self.session.sessionPreset = AVCaptureSessionPresetPhoto;  
	          
          //æ·»åŠ è¾“å…¥è¾“å‡º  
	        
          if ([self.session canAddInput:self.input]) {  
              [self.session addInput:self.input];  
          }  
	          
          if ([self.session canAddOutput:self.imageOutput]) {  
              [self.session addOutput:self.imageOutput];  
          }  
	          
          //ç”Ÿæˆé¢„è§ˆå±‚  
	        
          self.previewLayer = [[AVCaptureVideoPreviewLayer alloc] initWithSession:self.session];  
          self.previewLayer.frame = CGRectMake(0, 35, SCREEN_WIDTH, SCREEN_HEIGHT - self.bottomView.size.height - 35);  
          self.previewLayer.videoGravity = AVLayerVideoGravityResizeAspectFill;  
          self.previewLayer.backgroundColor = [UIColor blackColor].CGColor;  
          [self.view.layer addSublayer:self.previewLayer];  
	          
          if ([_device lockForConfiguration:nil]) {  
	              
              //è‡ªåŠ¨é—ªå…‰ç¯  
	            
              if ([_device isFlashModeSupported:AVCaptureFlashModeAuto]) {  
                  [_device setFlashMode:AVCaptureFlashModeAuto];  
              }  
	              
              //è‡ªåŠ¨ç™½å¹³è¡¡  
	            
              if ([_device isWhiteBalanceModeSupported:AVCaptureWhiteBalanceModeAutoWhiteBalance]) {  
                  [_device setWhiteBalanceMode:AVCaptureWhiteBalanceModeAutoWhiteBalance];  
              }  
	              
              [_device unlockForConfiguration];  
          }  
	          
          //å¼€å§‹å–æ™¯  
	        
          [self.session startRunning];  
      }  
	
      //æ ¹æ®å‰åç½®ä½ç½®è·å–ç›¸åº”çš„æ‘„åƒå¤´  
	    
      - (AVCaptureDevice *)camerWithPosition:(AVCaptureDevicePosition)position{  
	      
          NSArray *devices = [AVCaptureDevice     devicesWithMediaType:AVMediaTypeVideo];  
          for (AVCaptureDevice *device in devices) {  
              if (device.position == position) {  
                  return device;  
              }  
          }  
	      
          return nil;  
      } 
</code></pre></div>    </div>
  </li>
  <li>
    <p>é—ªå…‰ç¯è®¾ç½®</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      // è®¾ç½®é—ªå…‰ç¯çŠ¶æ€ä¸ºæ‰“å¼€  
      [self.device lockForConfiguration:nil];  
      if ([self.device hasFlash]) {  
          if ([_device isFlashModeSupported:AVCaptureFlashModeOn]) {  
              [_device setFlashMode:AVCaptureFlashModeOn];  
          }  
      }  
      [self.device unlockForConfiguration]; 
	
	
      // è®¾ç½®é—ªå…‰ç¯çŠ¶æ€ä¸ºå…³é—­  
      [self.device lockForConfiguration:nil];  
      if ([self.device hasFlash]) {  
           if ([_device isFlashModeSupported:AVCaptureFlashModeOff]) {  
               [_device setFlashMode:AVCaptureFlashModeOff];  
           }  
      }  
      [self.device unlockForConfiguration];  
	
</code></pre></div>    </div>
  </li>
  <li>
    <p>å‰åæ‘„åƒå¤´åˆ‡æ¢</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> - (IBAction)switchCameraButtonClicked:(id)sender {  
	      
     [self changeCamera];  
	      
     //å»¶è¿Ÿä¸€ç§’è®¾ç½®ç›¸æœºåˆå§‹ç„¦ç‚¹  
     __weak typeof(self) weakSelf = self;  
     dispatch_time_t delayTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0 * NSEC_PER_SEC));  
     dispatch_after(delayTime, dispatch_get_main_queue(), ^{  
         [weakSelf setupFocusPointManual]; //è®¾ç½®åˆå§‹ç„¦ç‚¹å±…ä¸­  
     });  
	      
 }  
	
 - (void)changeCamera{  
	          
      NSUInteger cameraCount = [[AVCaptureDevice devicesWithMediaType:AVMediaTypeVideo] count];  
	          
      if (cameraCount &gt; 1) {  
	              
          NSError *error;  
          //ç»™æ‘„åƒå¤´çš„åˆ‡æ¢æ·»åŠ ç¿»è½¬åŠ¨ç”»  
          CATransition *animation = [CATransition animation];  
          animation.duration = 0.5f;  
          animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionLinear];  
          animation.type = @"oglFlip";  
          animation.subtype = kCATransitionFromLeft;  
	              
          AVCaptureDevice *newCamera = nil;  
          AVCaptureDeviceInput *newInput = nil;  
          //æ‹¿åˆ°å¦å¤–ä¸€ä¸ªæ‘„åƒå¤´ä½ç½®  
          AVCaptureDevicePosition position = [[_input device] position];  
	              
          if (position == AVCaptureDevicePositionFront){  
              newCamera = [self camerWithPosition:AVCaptureDevicePositionBack];       
          }  
          else {  
              newCamera = [self camerWithPosition:AVCaptureDevicePositionFront];  
              self.lightBtn.selected = YES;  
              [self autoButtonClicked:self.autoBtn];       
          }  
	    
          //ç”Ÿæˆæ–°çš„è¾“å…¥  
          newInput = [AVCaptureDeviceInput deviceInputWithDevice:newCamera error:nil];  
          if (newInput != nil) {  
              [self.session beginConfiguration];  
              [self.session removeInput:self.input];  
              if ([self.session canAddInput:newInput]) {  
                  [self.session addInput:newInput];  
                  self.input = newInput;       
              } else {  
                  [self.session addInput:self.input];  
              }  
              [self.session commitConfiguration];  
	                  
          } else if (error) {  
              NSLog(@"toggle carema failed, error = %@", error);  
          }  
	              
       [self.previewLayer addAnimation:animation forKey:@"OglFlipAnimation"];  
      }  
  }  
	    
 - (void)setupFocusPointManual{  
	      
     CGPoint point = CGPointMake(SCREEN_WIDTH / 2.0, 35 + self.previewLayer.bounds.size.height / 2.0);  
     [self focusAtPoint:point];  
 } 
	
 // è®¾ç½®ç›¸æœºç„¦ç‚¹
 - (void)focusAtPoint:(CGPoint)point{  
	      
     CGSize size = self.view.bounds.size;  
     CGPoint focusPoint = CGPointMake( point.y /size.height ,1-point.x/size.width );  
     NSError *error;  
     if ([self.device lockForConfiguration:&amp;error]) {  
	          
         if ([self.device isFocusModeSupported:AVCaptureFocusModeAutoFocus]) {  
             [self.device setFocusPointOfInterest:focusPoint];  
             [self.device setFocusMode:AVCaptureFocusModeAutoFocus];  
         }  
	          
         if ([self.device isExposureModeSupported:AVCaptureExposureModeAutoExpose ]) {  
             [self.device setExposurePointOfInterest:focusPoint];  
             [self.device setExposureMode:AVCaptureExposureModeAutoExpose];  
         }  
	          
         [self.device unlockForConfiguration];  
         _focusView.center = point;  
         _focusView.hidden = NO;  
         [UIView animateWithDuration:0.3 animations:^{  
             _focusView.transform = CGAffineTransformMakeScale(1.25, 1.25);  
         }completion:^(BOOL finished) {  
             [UIView animateWithDuration:0.5 animations:^{  
                 _focusView.transform = CGAffineTransformIdentity;  
             } completion:^(BOOL finished) {  
                 _focusView.hidden = YES;  
             }];  
         }];  
     }  
	      
 }
	
 // æ ¹æ®ç‚¹å‡»æ‰‹åŠ¿è®¾ç½®ç„¦ç‚¹  
 - (void)focusGesture:(UITapGestureRecognizer*)gesture{  
     CGPoint point = [gesture locationInView:gesture.view];  
     CGRect frame = self.previewLayer.frame;  
	      
     //å»é™¤é¢„è§ˆåŒºä»¥å¤–çš„ç‚¹  
     if ((point.x &gt;= frame.origin.x &amp;&amp; point.x &lt;= frame.origin.x + frame.size.width) &amp;&amp;  
         (point.y &gt;= frame.origin.y &amp;&amp; point.y &lt;= frame.origin.y + frame.size.height)) {  
	      
         [self focusAtPoint:point];  
     }  
 } 
	
</code></pre></div>    </div>
  </li>
  <li>
    <p>æ‹ç…§ã€è·å–ç…§ç‰‡</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  - (void)takePhotos{  
	      
      AVCaptureConnection *conntion = [self.imageOutput connectionWithMediaType:AVMediaTypeVideo];  
      if (!conntion) {  
          [YMLPrompt showMessage:@"æ‹ç…§å¤±è´¥ï¼Œè¯·é‡è¯•" delay:3.0f];  
          return;  
      }  
	      
      [self.imageOutput captureStillImageAsynchronouslyFromConnection:conntion completionHandler:^(CMSampleBufferRef imageDataSampleBuffer, NSError *error) {  
	          
          if (imageDataSampleBuffer == nil) {  
              return ;  
          }  
	          
          NSData *imageData = [AVCaptureStillImageOutput jpegStillImageNSDataRepresentation:imageDataSampleBuffer];  
          UIImage *image = [UIImage imageWithData:imageData];  
	          
          image = [image normalizedImage]; //ä¿®æ­£å›¾ç‰‡æ–¹å‘  
	          
          [self.session stopRunning];  
      }];  
	      
  }
</code></pre></div>    </div>
  </li>
  <li>
    <p>è·å–ç…§ç‰‡åï¼Œä¿å­˜åˆ°ç›¸å†Œ</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  - (void)saveImageToPhotoAlbum:(UIImage *)savedImage{  
	      
      UIImageWriteToSavedPhotosAlbum(savedImage, self, @selector(image:didFinishSavingWithError:contextInfo:), NULL);  
  }  
	  
  // ä¿å­˜å®Œæˆå›è°ƒ  
  - (void)image:(UIImage *)image didFinishSavingWithError:(NSError *)error contextInfo:(voidvoid *)contextInfo  
	  
  {  
      NSString *msg = nil ;  
      if(error != NULL){  
          msg = @"ä¿å­˜å›¾ç‰‡å¤±è´¥" ;  
      }else{  
          msg = @"ä¿å­˜å›¾ç‰‡æˆåŠŸ" ;  
      }  
      kLog(@"%@",msg);  
  }
</code></pre></div>    </div>
  </li>
</ul>

<p><strong>æ³¨æ„ç‚¹ï¼š</strong></p>
<ul>
  <li>ç”±äºç›®å‰è‹¹æœå¯¹ç”¨æˆ·éšç§çš„ä¿æŠ¤ï¼Œéœ€è¦åœ¨ Info.plist æ–‡ä»¶ä¸­æ·»åŠ å¦‚ä¸‹ä¿¡æ¯ï¼š
                       <key>NSCameraUsageDescription</key>
                       <string>ç›¸æœºä½¿ç”¨è¯´æ˜</string>
                       <key>NSPhotoLibraryUsageDescription</key>
                       <string>ç›¸å†Œä½¿ç”¨è¯´æ˜</string></li>
  <li>ç›¸æœºæ‹ç…§é»˜è®¤æ˜¯æ¨ªå±çš„ï¼ˆHomeé”®åœ¨å³æ‰‹ä¾§ï¼‰ï¼Œæ‹å‡ºæ¥çš„ç…§ç‰‡æ–¹å‘ä¸æ˜¯å‘ä¸Šçš„ï¼Œåœ¨ç›´æ¥é¢„è§ˆæˆ–è€…åœ¨ç›¸å†Œä¸­æŸ¥çœ‹å´éƒ½æ˜¯æ–¹å‘å‘ä¸Šçš„ï¼Œä½†æ˜¯åœ¨è£å‰ªä¹‹åå¾—  åˆ°çš„å›¾ç‰‡æ–¹å‘ä¸æ˜¯å‘ä¸Šçš„ã€‚é€šè¿‡å›¾ç‰‡çš„ imageOrientation å±æ€§å¯ä»¥çœ‹åˆ°ï¼Œæ‹å‡ºæ¥çš„å›¾ç‰‡æ–¹å‘æ˜¯ UIImageOrientationRightï¼Œæ‰€ä»¥éœ€è¦è°ƒæ•´å›¾ç‰‡æ–¹å‘</li>
</ul>

<p><strong>åœ¨UIImageç±»åˆ«ä¸­æ·»åŠ ä¸€ä¸ªä¿®æ­£å›¾ç‰‡æ–¹å‘çš„æ–¹æ³•:</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- (UIImage *)normalizedImage {
	    
	if (self.imageOrientation == UIImageOrientationUp) return self;
	
	UIGraphicsBeginImageContextWithOptions(self.size, NO, self.scale);
	[self drawInRect:(CGRect){0, 0, self.size}];
	UIImage *normalizedImage = UIGraphicsGetImageFromCurrentImageContext();
	UIGraphicsEndImageContext();
	    
	return normalizedImage;
}
</code></pre></div></div>

<p><strong>å¯¹å›¾ç‰‡è¿›è¡Œè£å‰ª</strong></p>

<p>è£å‰ªå›¾ç‰‡åœ¨ GHPhotoClipView ç±»ä¸­å®ç°</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    #import &lt;UIKit/UIKit.h&gt;  
      
    @interface GHPhotoClipView : UIView  
      
    /** ç”¨äºè£å‰ªçš„åŸå§‹å›¾ç‰‡ */  
    @property (strong, nonatomic) UIImage *image;  
      
    /** é‡æ–°æ‹ç…§block */  
    @property (copy, nonatomic) void(^remakeBlock)();  
      
    /** è£å‰ªå®Œæˆblock */  
    @property (copy, nonatomic) void(^sureUseBlock)(UIImage *image);  
      
      
    @end  
</code></pre></div></div>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    #import "GHPhotoClipView.h"  
    
    #import "GHPhotoClipCoverView.h"  
      
    @interface GHPhotoClipView ()  
      
    /** å›¾ç‰‡ */  
    @property (strong, nonatomic) UIImageView *imageV;  
      
    /** å›¾ç‰‡åŠ è½½åçš„åˆå§‹ä½ç½® */  
    @property (assign, nonatomic) CGRect norRect;  
      
    /** è£å‰ªæ¡†frame */  
    @property (assign, nonatomic) CGRect showRect;  
      
      
    @end  
      
    @implementation GHPhotoClipView  
      
    - (instancetype)initWithFrame:(CGRect)frame{  
          
        self = [super initWithFrame:frame];  
          
        if (self) {  
              
            self.backgroundColor = [UIColor blackColor];  
            [self createSubViews];  
        }  
        return self;  
    }  
      
    - (void)createSubViews{  
        // æ·»åŠ å›¾ç‰‡  
        
        self.imageV = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0 , self.frame.size.width, self.frame.size.width)];  
        [self addSubview:self.imageV];  
      
        // è£å‰ªå±‚
        
        GHPhotoClipCoverView *coverView = [[GHPhotoClipCoverView alloc] initWithFrame:self.bounds];  
        [coverView addGestureRecognizer:[[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(panGR:)]];  
        [coverView addGestureRecognizer:[[UIPinchGestureRecognizer alloc] initWithTarget:self action:@selector(pinGR:)]];  
        self.showRect = CGRectMake(1, self.frame.size.height * 0.15,self.frame.size.width - 2 ,self.frame.size.width - 2);  
        coverView.showRect = self.showRect;  
        [self addSubview:coverView];  

        // åº•éƒ¨view  
        
        UIView *bottomView = [[UIView alloc] initWithFrame:CGRectMake(0, self.frame.size.height - 60, self.frame.size.width, 60)];  
        bottomView.backgroundColor = [[UIColor blackColor] colorWithAlphaComponent:0.6f];  
        [coverView addSubview:bottomView];  
        [YMLFactory btnWithFrame:CGRectMake(10, 15, 60, 30) Type:UIButtonTypeCustom Title:@"é‡æ‹" fontSize:15 titleColor:[UIColor whiteColor] bgColor:[UIColor clearColor] target:self selector:@selector(leftButtonClicked) superView:bottomView];  
        [YMLFactory btnWithFrame:CGRectMake(bottomView.frame.size.width - 90, 15, 80, 30) Type:UIButtonTypeCustom Title:@"ä½¿ç”¨ç…§ç‰‡" fontSize:15 titleColor:[UIColor whiteColor] bgColor:[UIColor clearColor] target:self selector:@selector(rightButtonClicked) superView:bottomView];  
          
    }  
      
    - (void)setImage:(UIImage *)image{  
          
        if (image) {  
            CGFloat ret = image.size.height / image.size.width;  
            _imageV.height = _imageV.width * ret;  
            _imageV.center = self.center;  
            _norRect = _imageV.frame;  
            _imageV.image = image;  
        }  
          
        _image = image;  
          
    }  
      
    // æ‹–åŠ¨æ‰‹åŠ¿
    
    - (void)panGR:(UIPanGestureRecognizer *)sender{  
          
        CGPoint point = [sender translationInView:self];  
        kLog(@"%f %f",point.x,point.y);  
        _imageV.center = CGPointMake(_imageV.centerX + point.x, _imageV.centerY + point.y);  
        [sender setTranslation:CGPointZero inView:self];  
          
        if (sender.state == UIGestureRecognizerStateEnded) {  
              
            [UIView animateWithDuration:0.3f animations:^{  
                _imageV.frame = _norRect;  
            }];  
        }  
    }  
      
    // ç¼©æ”¾æ‰‹åŠ¿
    
    - (void)pinGR:(UIPinchGestureRecognizer *)sender{  
          
        _imageV.transform = CGAffineTransformScale(_imageV.transform, sender.scale, sender.scale);  
      
        sender.scale = 1.0;  
          
        if (sender.state == UIGestureRecognizerStateEnded) {  
              
            [UIView animateWithDuration:0.3f animations:^{  
                _imageV.frame = _norRect;  
            }];  
        }  
    }  
      
      
    #pragma mark -- é‡æ‹  
      
    - (void)leftButtonClicked{  
        kLog(@"é‡æ‹");  
        if (self.remakeBlock) {  
            self.remakeBlock();  
        }  
          
    }  
      
    #pragma mark -- ä½¿ç”¨ç…§ç‰‡  
      
    - (void)rightButtonClicked{  
        kLog(@"ä½¿ç”¨ç…§ç‰‡");  
          
        CGFloat w = self.image.size.width;  
        CGFloat h = self.image.size.height;  
      
        CGFloat originX = (1- self.showRect.size.width / self.norRect.size.width) / 2.0 * w;  
        CGFloat originY = (self.showRect.origin.y - self.norRect.origin.y) / self.norRect.size.height * h;  
        CGFloat clipW = self.showRect.size.width / self.norRect.size.width * w;  
        CGFloat clipH = self.showRect.size.height / self.norRect.size.height * h;  
          
        CGRect clipRect = CGRectMake(originX, originY, clipW, clipH);  
        UIImage *image = [Tools imageFromImage:self.image inRect:clipRect];  
      
        _imageV.image = image;  
          
        if (self.sureUseBlock) {  
            self.sureUseBlock(image);  
        }  
    }  
     
    @end  
</code></pre></div></div>

<p><strong>è£å‰ªå›¾ç‰‡çš„æ–¹æ³•</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    /** 
     * ä»å›¾ç‰‡ä¸­æŒ‰æŒ‡å®šçš„ä½ç½®å¤§å°æˆªå–å›¾ç‰‡çš„ä¸€éƒ¨åˆ† 
     * UIImage image åŸå§‹çš„å›¾ç‰‡ 
     * CGRect rect è¦æˆªå–çš„åŒºåŸŸ 
     */  
    + (UIImage *)imageFromImage:(UIImage *)image inRect:(CGRect)rect{  
          
        //å°†UIImageè½¬æ¢æˆCGImageRef  
        CGImageRef sourceImageRef = [image CGImage];  
          
        //æŒ‰ç…§ç»™å®šçš„çŸ©å½¢åŒºåŸŸè¿›è¡Œå‰ªè£  
        CGImageRef newImageRef = CGImageCreateWithImageInRect(sourceImageRef, rect);  
          
        //å°†CGImageRefè½¬æ¢æˆUIImage  
        UIImage *newImage = [UIImage imageWithCGImage:newImageRef];  
          
        //è¿”å›å‰ªè£åçš„å›¾ç‰‡  
        return newImage;  
    }  
</code></pre></div></div>

<p><strong>è£å‰ªæ¡†æ•ˆæœ</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#import &lt;UIKit/UIKit.h&gt;  
  
@interface GHPhotoClipCoverView : UIView  
  
/** æ˜¾ç¤ºæ–¹æ¡†åŒºåŸŸ */  
@property (assign, nonatomic) CGRect showRect;  
  
@end 



#import "GHPhotoClipCoverView.h"  
      
@implementation GHPhotoClipCoverView  
      
- (instancetype)initWithFrame:(CGRect)frame{  
          
    self = [super initWithFrame:frame];  
          
    if (self) {  
        self.backgroundColor = [UIColor clearColor];  
    }  
    return self;  
}  
      
- (void)drawRect:(CGRect)rect{  
          
    [super drawRect:rect];  
          
    CGContextRef ctx = UIGraphicsGetCurrentContext();  
          
    // æ•´ä½“é¢œè‰²  
    
    CGContextSetRGBFillColor(ctx, 0.15, 0.15, 0.15, 0.6);  
    CGContextFillRect(ctx, rect);   //draw the transparent layer  
          
    // ä¸­é—´æ¸…ç©ºçŸ©å½¢æ¡†  
    
    CGRect clearDrawRect = self.showRect;  
    CGContextClearRect(ctx, clearDrawRect);  
          
    // è¾¹æ¡†  
    
    CGContextStrokeRect(ctx, clearDrawRect);  
    
    //é¢œè‰²  
    
    CGContextSetRGBStrokeColor(ctx, 1, 1, 1, 1);  
    
    //çº¿å®½  
    
    CGContextSetLineWidth(ctx, 0.5);              
    
    //çŸ©å½¢  
    
    CGContextAddRect(ctx, clearDrawRect);         
    
    CGContextStrokePath(ctx);  
}  
    
@end  

</code></pre></div></div>

<p>å®Œæ•´Demoåœ°å€ï¼š<a href="https://github.com/HuberyYang/CameraDemo.git">CameraDemo</a></p>

:ET